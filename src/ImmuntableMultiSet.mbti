package "BigOrangeQWQ/ImmuntableMultiSet"

import(
  "moonbitlang/core/immut/hashmap"
  "moonbitlang/core/set"
)

// Values
fn add[T : Eq + Hash](ImmutableMultiset[T], T, times~ : Int = ..) -> ImmutableMultiset[T]

fn contains[T : Eq + Hash](ImmutableMultiset[T], T) -> Bool

fn count[T : Eq + Hash](ImmutableMultiset[T], T) -> Int

fn difference[T : Eq + Hash](ImmutableMultiset[T], ImmutableMultiset[T]) -> ImmutableMultiset[T]

fn elems[T : Eq + Hash](ImmutableMultiset[T]) -> Iter[T]

fn from_array[T : Eq + Hash](Array[T]) -> ImmutableMultiset[T]

fn from_iter[T : Eq + Hash](Iter[T]) -> ImmutableMultiset[T]

fn from_iter2[T : Eq + Hash](Iter2[T, Int]) -> ImmutableMultiset[T]

fn from_set[T : Eq + Hash](@set.Set[T]) -> ImmutableMultiset[T]

fn intersection[T : Eq + Hash](ImmutableMultiset[T], ImmutableMultiset[T]) -> ImmutableMultiset[T]

fn is_empty[T](ImmutableMultiset[T]) -> Bool

fn iter[T : Eq + Hash](ImmutableMultiset[T]) -> Iter[(T, Int)]

fn iter2[T : Eq + Hash](ImmutableMultiset[T]) -> Iter2[T, Int]

fn of[T : Eq + Hash](FixedArray[T]) -> ImmutableMultiset[T]

fn op_get[T : Eq + Hash](ImmutableMultiset[T], T) -> Int

fn remove[T : Eq + Hash](ImmutableMultiset[T], T, times~ : Int = ..) -> ImmutableMultiset[T]

fn set[T : Eq + Hash](ImmutableMultiset[T], T, times~ : Int = ..) -> ImmutableMultiset[T]

fn size[T](ImmutableMultiset[T]) -> Int

fn union[T : Eq + Hash](ImmutableMultiset[T], ImmutableMultiset[T]) -> ImmutableMultiset[T]

// Types and methods
pub struct ImmutableMultiset[T] {
  mut map : @hashmap.T[T, Int]
  size : Int
}
impl ImmutableMultiset {
  add[T : Eq + Hash](Self[T], T, times~ : Int = ..) -> Self[T]
  contains[T : Eq + Hash](Self[T], T) -> Bool
  count[T : Eq + Hash](Self[T], T) -> Int
  difference[T : Eq + Hash](Self[T], Self[T]) -> Self[T]
  elems[T : Eq + Hash](Self[T]) -> Iter[T]
  intersection[T : Eq + Hash](Self[T], Self[T]) -> Self[T]
  is_empty[T](Self[T]) -> Bool
  iter[T : Eq + Hash](Self[T]) -> Iter[(T, Int)]
  iter2[T : Eq + Hash](Self[T]) -> Iter2[T, Int]
  new[T]() -> Self[T]
  op_get[T : Eq + Hash](Self[T], T) -> Int
  remove[T : Eq + Hash](Self[T], T, times~ : Int = ..) -> Self[T]
  set[T : Eq + Hash](Self[T], T, times~ : Int = ..) -> Self[T]
  size[T](Self[T]) -> Int
  union[T : Eq + Hash](Self[T], Self[T]) -> Self[T]
}
impl[T : Eq + Hash] BitAnd for ImmutableMultiset[T]
impl[T : Eq + Hash] BitOr for ImmutableMultiset[T]
impl[T : Eq + Hash] Eq for ImmutableMultiset[T]
impl[T : Eq + Hash] Sub for ImmutableMultiset[T]

// Type aliases

// Traits

